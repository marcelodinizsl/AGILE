https://msdn.microsoft.com/en-us/library/dn223671(v=pandp.30).aspx
@ DEPENDENCY INJECTION

Loose Coupling - It's a opposed to tight coupling, means reducing the number of dependencies between the components that make up your system. This makes it easier and safer to make changes in one area of the system because each part of the system is largely independent of the other.

It's possible address some of the most of the most common requirements in enterprise applications by adopting a loosely design to minimize the dependencies between the different part of your application. However, if a class does not directly instantiate the other that it needs, some other class or component must take on this responsibility. We can use patterns that you can use to manage how objects are instantiated in our application before focusing specifically on dependency injection as the mechanism to use in enterprise applications.

Factories, service locators and depen injection are all approaches you can take to move the responsibility for instantiating and managing objects on behalf of other client objects.

# FACTORY PATTERNS

There are three common factory patterns 
- The Factory Method
- Abstract Factory patterns
- Simple Factory PATTERNS

$ THE FACTORY METHOD PATTERN

This pattern enables you to modify the behavior of a class without modifying the class itself by using inheritance.

public class Managment
{
   protected ITenantStore tenantStore;
   
   public Management()
   {
      this.tenantStore = CreateTenantStore();
   }
   
   protected virtual ITenantStore CreateTrenantStore()
   {
	  return new TenantStore();
   }
   
   public ActionResult Index()
   {
      var model = this.tenantStore.GetTenantNames();
	  
	  return this.View(model);
   }
}

public class SQLManagment: Management
{
   protected override ITenantStore CreateTenantStore()
   {
      ...
	  return SQLTenantStore();
   }
}

This approach results in a flexible and extensible design and impements the open/closed principle. However, it does not result in a maintainable solution because all the client classes that use the TenantStore class are still responsable for instantiating TenantStore instances correctly and consistently. It is also still difficult to test the Management class because it depends on the TeanantStore type.
One approach to testing would be to create a MockManagement type that derives from Management and that uses a mock storage implementation to return test data: in other words you must create two mock types to manage testing.

$ Single Factory PATTERN

While the factory method pattern does not remove the dependencies from the high-level client class, such as the Management class, on the low-level, you can achieve this with the simple factory pattern.

public class Management
{
  private readonly ITenantStore tenantStore;
  
  public Management()
  {
	var tenantStoreFactory =  new TenantStoreFactory();
	this.tenantStore = tenantStoreFactory.CreateTenantStore();
  }
  
  public ActionResult Index()
  {
	var mode = this.tenantStore.GetTenantNames();
	
	return this.View(model);
  }
}

This approach removes much of the complexity from the high-level Management class, although in this example the Management class is still responsible for selecting the specific type of tenant store to use. We could easily move this logic into the factory class that could read a configuration setting to determine whether to create a Blob or a Sql instance. Making the factory class responsable for selecting the specifif type to create  makes it easier to apply a consistent approach throughout the application.

$ ABSTRACT FACTORY PATTERN

One of the problems that can arise from using the simple factory pattern in a large application is that it can be difficult to maintain consistency. The application may include multiple store classes such as SurveyStore, LogoStore and ReportStore classes in addition to the TenantStore classe.
The abstract factory pattern is useful if you have a requirement to create families of related objects in a consistent way.

$ SERVICE LOCATOR PATTERN

Using a service locator provides another variation to this general approach of using another class to create objects on you behalf. It's like as a registry that you can look up an instance of an object or service that another class in your application created and registered with the service locator. The service locator might support querying for objects by a string key or by interface type.

Often, in constrast to the factory patterns where the factory creates the object but gives responsability for managing the lifetime to the client class, the service locator is responsable for managing the lifetime of the object and simply returns a reference to the client. Also, factories are typically responsible for creating instances of specific types or families of types as in the case of the abstract factory pattern, while a service locator may be capable of returning a reference to an object of any type in the application.

Any classes that retrieve object references or service references from the service locator will  have a dependency on the service locator itself.

$ DEPENDENCY INJECTION

A common feature of the all the factory patterns and the service locator pattern, is that it is still the high-level client object's responsability to resolve its own dependencies by requesting the specific of the types that it needs.

They each adopt a pull model of varying degrees of sophistication, assigning various responsabilities to the factory or service locator. The pull model also means that the high-level client class has a dependency on the class that is responsible for creating of locating the object it wants to use. This also means that the dependencies of the high-level client are hidden inside of those classes rather specified in a single location, making them harder to test.

Dependency injection takes the opposite approach, adopting a push model in place of the pull model. Inversion of Control is a term that's often used to describe this push model and dependency injection is one specific implementation of the inversion of control technique.
With dependency injection, another class is responsible for injecting (pushing) the dependencies into the high-level client classes, at the runtime.

Martin Fowler -> With service locator the application class asks for it explicity by a message to the locator. With injection there is no explicit request, the service appears in the application class - hence the inversion of control."

public class Management
{
	private readonly ITenantStore tenantStore;
	
	public Management(ITenantStore tenantStore)
	{
		this.tenantStore = tenantStore;
	}
	
	public ActionResult Index()
	{
		var model = this.tenantStore.GetTenantNames();
		...
		return this.View(model);
	}
}
